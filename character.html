<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>16-Bit CV Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
  <!-- NOTE: THE GAME IS RENDERED IN CHARACTER.HTML -->
<body>
  <!-- Background Canvas -->
  <canvas id="background"></canvas>

  <!-- Character Canvas -->
  <canvas id="character"></canvas>

  <script>
    // Select the background canvas and get the context
    const backgroundCanvas = document.getElementById("background");
    const ctxBackground = backgroundCanvas.getContext("2d");

    // Set canvas size
    backgroundCanvas.width = window.innerWidth;
    backgroundCanvas.height = window.innerHeight;

    // Colors for the scene
    const skyColor = "#87CEEB"; // Light blue for sky
    const grassColor = "#32CD32"; // Bright green for grass
    const cloudColor = "#FFFFFF"; // White for clouds

    // Draw the background
    function drawBackground() {
      // Sky
      ctxBackground.fillStyle = skyColor;
      ctxBackground.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);

      // Grass
      const grassHeight = backgroundCanvas.height / 4; // Bottom quarter for grass
      ctxBackground.fillStyle = grassColor;
      ctxBackground.fillRect(0, backgroundCanvas.height - grassHeight, backgroundCanvas.width, grassHeight);
    }

    // Draw a pixelated cloud using the shape described earlier
    function drawCloud(x, y) {
      ctxBackground.fillStyle = cloudColor;

      const cloudShape = [
        [1],              // Top row (single block)
        [1, 1, 1, 1, 1], // Second row (wider part)
        [1, 1, 1, 1, 1, 1, 1], // Third row
        [1, 1, 1, 1, 1], // Fourth row
      ];

      // Draw each row of the cloud
      for (let i = 0; i < cloudShape.length; i++) {
        const row = cloudShape[i];
        const startX = x - Math.floor(row.length / 2) * 20; // Center the row horizontally
        const startY = y + (i * 20); // Increase Y for each row

        // Draw the blocks in this row
        for (let j = 0; j < row.length; j++) {
          ctxBackground.fillRect(startX + j * 20, startY, 20, 20);
        }
      }
    }

    // Draw multiple clouds
    function drawClouds() {
      drawCloud(100, 50);  // Cloud 1
      drawCloud(300, 100); // Cloud 2
      drawCloud(600, 70);  // Cloud 3
      drawCloud(900, 150); // Cloud 4
    }

    // Render the entire background scene
    function renderBackground() {
      drawBackground();
      drawClouds();
    }

    renderBackground(); // Initial render of the background


    // Select the character canvas and get the context
    const canvas = document.getElementById("character");
    const ctx = canvas.getContext("2d");

    // Set canvas size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Character properties
    const character = {
      x: 100,
      y: canvas.height - 150,  // Starting position
      width: 50,
      height: 50,
      speed: 5,
      dx: 0,  // Movement in x direction
      dy: 0,  // Movement in y direction
      gravity: 0.8,  // Gravity strength
      jumpPower: -15, // Jumping force
      grounded: false,  // Whether the character is on the ground
    };

    // Handle key presses for movement
    const keys = {
      right: false,
      left: false,
      up: false,
    };

    // Listen for keydown and keyup events
    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight" || e.key === "d") {
        keys.right = true;
      } else if (e.key === "ArrowLeft" || e.key === "a") {
        keys.left = true;
      } else if (e.key === "ArrowUp" || e.key === "w") {
        if (character.grounded) {
          character.dy = character.jumpPower;
          character.grounded = false;
        }
      }
    });

    document.addEventListener("keyup", (e) => {
      if (e.key === "ArrowRight" || e.key === "d") {
        keys.right = false;
      } else if (e.key === "ArrowLeft" || e.key === "a") {
        keys.left = false;
      }
    });

    // Update character position
    function updateCharacter() {
      if (keys.right) {
        character.dx = character.speed;
      } else if (keys.left) {
        character.dx = -character.speed;
      } else {
        character.dx = 0;
      }

      // Gravity simulation
      if (character.y + character.height < canvas.height) {
        character.dy += character.gravity;
        character.grounded = false;
      } else {
        character.dy = 0;
        character.grounded = true;
        character.y = canvas.height - character.height;
      }

      // Move the character
      character.x += character.dx;
      character.y += character.dy;

      // Prevent the character from going off-screen
      if (character.x < 0) {
        character.x = 0;
      }
      if (character.x + character.width > canvas.width) {
        character.x = canvas.width - character.width;
      }
    }

    // Draw the character
    function drawCharacter() {
      ctx.fillStyle = "#FFD700";  // Character color (blonde)
      ctx.fillRect(character.x, character.y, character.width, character.height);
    }

    // Game loop
    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
      updateCharacter();  // Update character position
      drawCharacter();    // Draw the character

      requestAnimationFrame(gameLoop);  // Repeat the loop
    }

    gameLoop();  // Start the game loop
  </script>
</body>
</html>
